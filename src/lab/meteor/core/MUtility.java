package lab.meteor.core;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import lab.meteor.core.type.MBinary;
import lab.meteor.core.type.MCode;
import lab.meteor.core.type.MRef;

/**
 * The utility of meteor system. The responsibility are: 
 * <p>
 * 1. Converting the element ID between the form of string and long; <br>
 * 2. Check the type of Java object is a valid type in meteor system.
 * @author Qiang
 *
 */
public class MUtility {
	
	/**
	 * The alphabet used for generate strings of element ID.
	 */
	private static char[] alphabet = {
		'0','1','2','3','4','5','6','7','8','9',
		'a','b','c','d','e','f','g','h','i','j','k','l','m',
		'n','o','p','q','r','s','t','u','v','w','x','y','z',
		'A','B','C','D','E','F','G','H','I','J','K','L','M',
		'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
		'_','='
	};
	
	/**
	 * Convert element ID to string, in the radix of 64. The string may contains
	 * the characters: {@code 0-9, a-z, A-Z, _, =}. The generated string can be
	 * parsed by {@code MUtility.parseID()}.
	 * @param id element ID
	 * @return string
	 */
	public static String stringID(long id) {
		StringBuilder builder = new StringBuilder();
		int ch = 0;
		long _id = id;
		while (_id != 0) {
			ch = (int) (_id & 0x000000000000003FL);
			_id >>>= 6;
			builder.append(alphabet[ch]);
		}
		return builder.reverse().toString();
	}
	
	/**
	 * Parse the string generated by {@code MUtility.stringID()}.
	 * @param id ID in form of string
	 * @return element ID
	 */
	public static long parseID(String id) {
		char ch = '\0';
		long _id = 0;
		for (int i = 0; i < id.length(); i++) {
			int v = 0;
			_id <<= 6;
			ch = id.charAt(i);
			if (ch == '_')
				v = 62;
			else if (ch == '=')
				v = 63;
			else if ('0' <= ch && ch <= '9')
				v = ch - '0';
			else if ('a' <= ch && ch <= 'z')
				v = ch - 'a' + 10;
			else if ('A' <= ch && ch <= 'Z')
				v = ch - 'A' + 36;
			_id |= v;
		}
		return _id;
	}
	
	private static Map<Class<?>, MPrimitiveType> classes;
	
	static {
		classes = new HashMap<Class<?>, MPrimitiveType>();
		// Number
		classes.put(java.lang.Integer.class, MPrimitiveType.Integer);
		classes.put(java.lang.Long.class, MPrimitiveType.Int64);
		classes.put(java.lang.Float.class, MPrimitiveType.Number);
		classes.put(java.lang.Double.class, MPrimitiveType.Number);
		classes.put(java.lang.Short.class, MPrimitiveType.Number);
		classes.put(java.lang.Byte.class, MPrimitiveType.Number);
		// String
		classes.put(java.lang.String.class, MPrimitiveType.String);
		// Boolean
		classes.put(java.lang.Boolean.class, MPrimitiveType.Boolean);
		// DateTime
		classes.put(java.util.Date.class, MPrimitiveType.DateTime);
		classes.put(java.sql.Timestamp.class, MPrimitiveType.DateTime);
		// Bin
		classes.put(MBinary.class, MPrimitiveType.Binary);
		// Regex
		classes.put(java.util.regex.Pattern.class, MPrimitiveType.Regex);
		// Code
		classes.put(MCode.class, MPrimitiveType.Code);
		// Ref
		classes.put(MRef.class, MPrimitiveType.Ref);
	}
	
	/**
	 * Check the value can be handled by MObject or MTag. The values of MObject
	 * and MTag are only subset of Java Classes, e.g. {@code java.lang.Number}, 
	 * {@code java.lang.String}, {@code java.lang.Boolean}, 
	 * {@code java.util.Date}, {@code lab.meteor.MSymbol}, etc.
	 * @param value the value to be checked.
	 * @return true if valid
	 */
	public static boolean isValidValue(Object value) {
		if (classes.containsKey(value.getClass()))
			return true;
		if (value instanceof MObject)
			return true;
		return false;
	}
	
	/**
	 * Check the value matches with the type.
	 * @param type a instance of MType, i.e. MPrimitiveType or MEnum.
	 * @param value the value to be checked.
	 * @return true if matches
	 */
	public static boolean checkType(MDataType type, Object value) {
		if (value == null)
			return true;
		MNativeDataType nType = type.getNativeDataType();
		switch (nType) {
		case Any:
			MPrimitiveType t = classes.get(value.getClass());
			if (t != null)
				return true;
			if (value instanceof MSymbol)
				return true;
			break;
		case Number:
			if (value instanceof java.lang.Number)
				return true;
			break;
		case Boolean:
			if (value instanceof java.lang.Boolean)
				return true;
			break;
		case String:
			if (value instanceof java.lang.String)
				return true;
			break;
		case DateTime:
			if (value instanceof java.util.Date)
				return true;
			break;
		case Enum:
			if (value instanceof MSymbol) {
				MSymbol sym = (MSymbol) value;
				if (sym.getEnum() == type)
					return true;
			}
			break;
		case List:
			if (value == MCollection.Factory.List)
				return true;
			break;
		case Set:
			if (value == MCollection.Factory.Set)
				return true;
			break;
		case Dictionary:
			if (value == MCollection.Factory.Dictionary)
				return true;
			break;
		case Binary:
			if (value instanceof MBinary)
				return true;
			break;
		case Regex:
			if (value instanceof Pattern)
				return true;
			break;
		case Integer:
			if (value instanceof java.lang.Integer)
				return true;
			break;
		case Int64:
			if (value instanceof java.lang.Long)
				return true;
			break;
		case Code:
			if (value instanceof MCode)
				return true;
			break;
		case Ref:
			if (value instanceof MRef)
				return true;
			break;
		default:
			return false;
		}
		return false;
	}
}
